/// <reference path="node-base-model.d.ts" />
import { ChildProperty } from '@syncfusion/ej2-base';
import { StrokeStyleModel, ShapeStyleModel } from '../core/appearance-model';
import { TextElement } from '../core/elements/text-element';
import { PointModel } from '../primitives/point-model';
import { Segments, DecoratorShapes, ConnectorConstraints, Direction, LayoutOrientation, Status } from '../enum/enum';
import { DecoratorModel, ConnectorShapeModel, BpmnFlowModel, VectorModel } from './connector-model';
import { Rect } from '../primitives/rect';
import { Bridge } from '../utility/connector';
import { PathElement } from '../core/elements/path-element';
import { PathAnnotation } from './annotation';
import { Canvas } from '../core/containers/canvas';
import { IElement } from './interface/IElement';
import { Container } from '../core/containers/container';
import { DiagramElement } from '../core/elements/diagram-element';
import { AssociationFlow, ClassifierShape, Multiplicity } from '../enum/enum';
import { ConnectionShapes, UmlActivityFlows, BpmnFlows, BpmnMessageFlows, BpmnSequenceFlows, BpmnAssociationFlows } from '../enum/enum';
import { PathAnnotationModel } from './annotation-model';
import { NodeBase } from './node-base';
import { DiagramTooltipModel } from './tooltip-model';
import { OrthogonalSegmentModel, StraightSegmentModel, BezierSegmentModel, ConnectorModel } from './connector-model';
import { RelationShipModel, ClassifierMultiplicityModel, MultiplicityLabelModel } from './connector-model';
import { DiagramHtmlElement } from '../core/elements/html-element';
/**
 * Decorators are used to decorate the end points of the connector with some predefined path geometry
 */
export declare class Decorator extends ChildProperty<Decorator> {
    /**
     * Sets the width of the decorator
     * @default 10
     */
    width: number;
    /**
     * Sets the height of the decorator
     * @default 10
     */
    height: number;
    /**
     * Sets the shape of the decorator
     * * None - Sets the decorator shape as None
     * * Arrow - Sets the decorator shape as Arrow
     * * Diamond - Sets the decorator shape as Diamond
     * * Path - Sets the decorator shape as Path
     * * OpenArrow - Sets the decorator shape as OpenArrow
     * * Circle - Sets the decorator shape as Circle
     * * Square - Sets the decorator shape as Square
     * * Fletch - Sets the decorator shape as Fletch
     * * OpenFetch - Sets the decorator shape as OpenFetch
     * * IndentedArrow - Sets the decorator shape as Indented Arrow
     * * OutdentedArrow - Sets the decorator shape as Outdented Arrow
     * * DoubleArrow - Sets the decorator shape as DoubleArrow
     * @default 'Arrow'
     */
    /**
     * ```html
     * <div id='diagram'></div>
     * ```
     * ```typescript
     * let connectors: ConnectorModel[] = [{
     *   id: 'connector', type: 'Straight', sourcePoint: { x: 500, y: 100 }, targetPoint: { x: 600, y: 200 },
     *   sourceDecorator: {
     *    style: { fill: 'black' },
     *    shape: 'Arrow',
     *    pivot: { x: 0, y: 0.5 }},
     *   targetDecorator: {
     *    shape: 'Diamond',
     *    style: { fill: 'blue' },
     *    pivot: { x: 0, y: 0.5 }}
     *  },];
     * let diagram: Diagram = new Diagram({
     * ...
     * connectors: connectors
     * ...
     * });
     * diagram.appendTo('#diagram');
     * ```
     */
    shape: DecoratorShapes;
    /**
     * Defines the appearance of the decorator
     * @default new ShapeStyle()
     */
    style: ShapeStyleModel;
    /**
     * Defines the position of the decorator with respect to the source/target point of the connector
     */
    pivot: PointModel;
    /**
     * Defines the geometry of the decorator shape
     * @default ''
     */
    pathData: string;
}
/**
 * Describes the length and angle between the control point and the start point of bezier segment
 */
export declare class Vector extends ChildProperty<Vector> {
    /**
     * Defines the angle between the connector end point and control point of the bezier segment
     * @default 0
     */
    angle: number;
    /**
     * Defines the distance between the connector end point and control point of the bezier segment
     * @default 0
     */
    distance: number;
}
/**
 * Sets the type of the connector
 */
export declare class ConnectorShape extends ChildProperty<ConnectorShape> {
    /**
     * Defines the application specific type of connector
     * * Bpmn - Sets the type of the connection shape as Bpmn
     * @default 'None'
     */
    type: ConnectionShapes;
}
/**
 * Sets the type of the flow in a BPMN Process
 */
export declare class ActivityFlow extends ConnectorShape {
    /**
     * Defines the type of the UMLActivity flows
     * Object - Sets the type of the UMLActivity Flow as Object
     * Control - Sets the type of the UMLActivity Flow as Control
     * Exception - Sets the type of the UMLActivity Flow as Exception
     * @default 'Object'
     * @IgnoreSingular
     */
    flow: UmlActivityFlows;
    /**
     * Defines the height of the exception flow.
     * @default '50'
     */
    exceptionFlowHeight: number;
}
/**
 * Sets the type of the flow in a BPMN Process
 */
export declare class BpmnFlow extends ConnectorShape {
    /**
     * Sets the type of the Bpmn flows
     * * Sequence - Sets the type of the Bpmn Flow as Sequence
     * * Association - Sets the type of the Bpmn Flow as Association
     * * Message - Sets the type of the Bpmn Flow as Message
     * @default 'Sequence'
     */
    flow: BpmnFlows;
    /**
     * Sets the type of the Bpmn Sequence flows
     * * Default - Sets the type of the sequence flow as Default
     * * Normal - Sets the type of the sequence flow as Normal
     * * Conditional - Sets the type of the sequence flow as Conditional
     * @default 'Normal'
     */
    sequence: BpmnSequenceFlows;
    /**
     * Sets the type of the Bpmn message flows
     * * Default - Sets the type of the Message flow as Default
     * * InitiatingMessage - Sets the type of the Message flow as InitiatingMessage
     * * NonInitiatingMessage - Sets the type of the Message flow as NonInitiatingMessage
     * @default ''
     */
    /**
     * ```html
     * <div id='diagram'></div>
     * ```
     * ```typescript
     * let nodes: NodeModel[] = [
     * {
     *   id: 'node1', width: 60, height: 60, offsetX: 75, offsetY: 90,
     *   shape: { type: 'Bpmn', shape: 'Event', event: { event: 'Start', trigger: 'Message' } },
     *     },
     * {
     *   id: 'node2', width: 75, height: 70, offsetX: 210, offsetY: 90,
     *   shape: { type: 'Bpmn', shape: 'Gateway', gateway: { type: 'None' } },
     *  }];
     * let connectors: ConnectorModel[] = [{
     *   id: 'connector', type: 'Straight', sourceID: 'node1', targetID: 'node2',
     *   shape: { type: 'Bpmn', flow: 'Message', message: 'InitiatingMessage' } as BpmnFlowModel
     *  },];
     * let diagram: Diagram = new Diagram({
     * ...
     * nodes: nodes, connectors: connectors
     * ...
     * });
     * diagram.appendTo('#diagram');
     * ```
     */
    message: BpmnMessageFlows;
    /**
     * Sets the type of the Bpmn association flows
     * * Default - Sets the type of Association flow as Default
     * * Directional - Sets the type of Association flow as Directional
     * * BiDirectional - Sets the type of Association flow as BiDirectional
     * @default ''
     */
    association: BpmnAssociationFlows;
}
/**
 * Defines the behavior of connector segments
 */
export declare class ConnectorSegment extends ChildProperty<ConnectorSegment> {
    /**
     * Defines the type of the segment
     * * Straight - Sets the segment type as Straight
     * * Orthogonal - Sets the segment type as Orthogonal
     * * Bezier - Sets the segment type as Bezier
     * @default 'Straight'
     */
    type: Segments;
    /**
     * @private
     */
    points: PointModel[];
    /**
     * @private
     */
    isTerminal: boolean;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
}
/**
 * Defines the behavior of straight segments
 */
export declare class StraightSegment extends ConnectorSegment {
    /**
     * Sets the end point of the connector segment
     * @default new Point(0,0)
     */
    point: PointModel;
}
/**
 * Defines the behavior of bezier segments
 */
export declare class BezierSegment extends StraightSegment {
    /**
     * @private
     * Sets the first control point of the bezier connector
     */
    bezierPoint1: PointModel;
    /**
     * @private
     *  Sets the second control point of the bezier connector
     */
    bezierPoint2: PointModel;
    /**
     * Sets the first control point of the connector
     * @default {}
     */
    point1: PointModel;
    /**
     * Sets the second control point of the connector
     * @default {}
     */
    point2: PointModel;
    /**
     * Defines the length and angle between the source point and the first control point of the diagram
     * @default {}
     */
    vector1: VectorModel;
    /**
     * Defines the length and angle between the target point and the second control point of the diagram
     * @default {}
     */
    vector2: VectorModel;
}
/**
 * Defines the behavior of orthogonal segments
 */
export declare class OrthogonalSegment extends ConnectorSegment {
    /**
     * Defines the length of orthogonal segment
     * ```html
     * <div id='diagram'></div>
     * ```
     * ```typescript
     * let connectors: ConnectorModel[] = [{
     *       id: 'link2', sourcePoint: { x: 0, y: 0 }, targetPoint: { x: 40, y: 40 }, type: 'Orthogonal',
     *       shape: {
     *           type: 'Bpmn',
     *           flow: 'Message',
     *           association: 'directional'
     *       }, style: {
     *           strokeDashArray: '2,2'
     *       },
     *       segments: [{ type: 'Orthogonal', length: 30, direction: 'Bottom' },
     *       { type: 'Orthogonal', length: 80, direction: 'Right' }]
     *   }];
     * let diagram: Diagram = new Diagram({
     * ...
     * connectors: connectors
     * ...
     * });
     * diagram.appendTo('#diagram');
     * ```
     * @default 0
     */
    length: number;
    /**
     * Sets the direction of orthogonal segment
     * * Left - Sets the direction type as Left
     * * Right - Sets the direction type as Right
     * * Top - Sets the direction type as Top
     * * Bottom - Sets the direction type as Bottom
     * @default null
     */
    direction: Direction;
}
/**
 * Get the direction of the control points while the bezier is connected to the node
 */
export declare function getDirection(bounds: Rect, points: PointModel, excludeBounds: boolean): string;
export declare function isEmptyVector(element: VectorModel): boolean;
/**
 * Get the bezier points if control points are not given.
 */
export declare function getBezierPoints(sourcePoint: PointModel, targetPoint: PointModel, direction?: string): PointModel;
/**
 * Get the bezier curve bounds.
 */
export declare function getBezierBounds(startPoint: PointModel, controlPoint1: PointModel, controlPoint2: PointModel, endPoint: PointModel, connector: Connector): Rect;
/**
 * Get the intermediate bezier curve for point over connector
 */
export declare function bezierPoints(connector: ConnectorModel, startPoint: PointModel, point1: PointModel, point2: PointModel, endPoint: PointModel, i: number, max: number): PointModel;
/**
 * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults
 */
export declare class MultiplicityLabel extends ChildProperty<MultiplicityLabel> {
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    optional: boolean;
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    lowerBounds: string;
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    upperBounds: string;
}
/**
 * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults
 */
export declare class ClassifierMultiplicity extends ChildProperty<ClassifierMultiplicity> {
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    type: Multiplicity;
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    target: MultiplicityLabelModel;
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    source: MultiplicityLabelModel;
}
/**
 * Defines the behavior of the UMLActivity shape
 */
export declare class RelationShip extends ConnectorShape {
    /**
     * Defines the type of the  UMLConnector
     * @default ''
     * @IgnoreSingular
     */
    type: ConnectionShapes;
    /**
     * Defines the association direction
     * @default ''
     * @IgnoreSingular
     */
    relationship: ClassifierShape;
    /**
     * Defines the association direction
     * @default ''
     * @IgnoreSingular
     */
    associationType: AssociationFlow;
    /**
     * Defines the type of the Classifier Multiplicity
     * @default ''
     * @IgnoreSingular
     */
    multiplicity: ClassifierMultiplicityModel;
}
/**
 * Connectors are used to create links between nodes
 */
export declare class Connector extends NodeBase implements IElement {
    /**
     * Defines the shape of the connector
     * @default 'Bpmn'
     * @aspType object
     */
    shape: ConnectorShapeModel | BpmnFlowModel | RelationShipModel;
    /**
     * Defines the constraints of connector
     * * None - Interaction of the connectors cannot be done.
     * * Select - Selects the connector.
     * * Delete - Delete the connector.
     * * Drag - Drag the connector.
     * * DragSourceEnd - Drag the source end of the connector.
     * * DragTargetEnd - Drag the target end of the connector.
     * * DragSegmentThump - Drag the segment thumb of the connector.
     * * AllowDrop - Allow to drop a node.
     * * Bridging - Creates bridge  on intersection of two connectors.
     * * InheritBridging - Creates bridge  on intersection of two connectors.
     * * PointerEvents - Sets the pointer events.
     * * Tooltip - Displays a tooltip for the connectors.
     * * InheritToolTip - Displays a tooltip for the connectors.
     * * Interaction - Features of the connector used for interaction.
     * * ReadOnly - Enables ReadOnly
     * @default 'None'
     * @aspNumberEnum
     */
    constraints: ConnectorConstraints;
    /**
     * Defines the bridgeSpace of connector
     * @default 10
     */
    bridgeSpace: number;
    /**
     * Defines the collection of textual annotations of connectors
     * @aspDefaultValueIgnore
     * @default undefined
     */
    /**
     * ```html
     * <div id='diagram'></div>
     * ```
     * ```typescript
     * let connectors: ConnectorModel[] = [{
     *   id: 'connector', type: 'Straight', sourcePoint: { x: 500, y: 100 }, targetPoint: { x: 600, y: 200 },
     * annotations: [{ content: 'No', offset: 0, alignment: 'After' }]
     * ];
     * let diagram: Diagram = new Diagram({
     * ...
     * connectors: connectors
     * ...
     * });
     * diagram.appendTo('#diagram');
     * ```
     */
    annotations: PathAnnotationModel[];
    /**
     * Sets the beginning point of the connector
     * @default new Point(0,0)
     */
    sourcePoint: PointModel;
    /**
     * Sets the end point of the connector
     * @default new Point(0,0)
     */
    targetPoint: PointModel;
    /**
     * Defines the segments
     * @default []
     * @aspType object
     */
    segments: (OrthogonalSegmentModel | StraightSegmentModel | BezierSegmentModel)[];
    /**
     * Sets the source node/connector object of the connector
     * @default null
     */
    sourceID: string;
    /**
     * Sets the target node/connector object of the connector
     * @default null
     */
    targetID: string;
    /**
     * Sets the connector padding value
     * @default 10
     */
    hitPadding: number;
    /**
     * Defines the type of the connector
     * * Straight - Sets the segment type as Straight
     * * Orthogonal - Sets the segment type as Orthogonal
     * * Bezier - Sets the segment type as Bezier
     * @default 'Straight'
     */
    type: Segments;
    /**
     * Sets the corner radius of the connector
     * @default 0
     */
    cornerRadius: number;
    /**
     * Defines the source decorator of the connector
     * @default new Decorator()
     */
    sourceDecorator: DecoratorModel;
    /**
     * Defines the target decorator of the connector
     * @default new Decorator()
     */
    targetDecorator: DecoratorModel;
    /**
     * defines the tooltip for the connector
     * @default new DiagramToolTip();
     */
    tooltip: DiagramTooltipModel;
    /**
     * Sets the unique id of the source port of the connector
     * @default ''
     */
    sourcePortID: string;
    /**
     * Sets the unique id of the target port of the connector
     * @default ''
     */
    targetPortID: string;
    /**
     * Defines the appearance of the connection path
     * @default ''
     */
    style: StrokeStyleModel;
    /** @private */
    parentId: string;
    /**
     * Defines the UI of the connector
     * @default null
     */
    wrapper: Container;
    /** @private */
    bridges: Bridge[];
    /** @private */
    sourceWrapper: DiagramElement;
    /** @private */
    targetWrapper: DiagramElement;
    /** @private */
    sourcePortWrapper: DiagramElement;
    /** @private */
    targetPortWrapper: DiagramElement;
    /** @private */
    intermediatePoints: PointModel[];
    /** @private */
    status: Status;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
    /** @private */
    init(diagram: any): Canvas;
    private getConnectorRelation;
    private getBpmnSequenceFlow;
    /** @private */
    getUMLObjectFlow(): void;
    /** @private */
    getUMLExceptionFlow(segment: PathElement): void;
    private getBpmnAssociationFlow;
    private getBpmnMessageFlow;
    /** @private */
    distance(pt1: PointModel, pt2: PointModel): number;
    /**   @private  */
    findPath(sourcePt: PointModel, targetPt: PointModel): Object;
    /** @private */
    getAnnotationElement(annotation: PathAnnotation, points: PointModel[], bounds: Rect, getDescription: Function | string, diagramId: string): TextElement | DiagramHtmlElement;
    /** @private */
    updateAnnotation(annotation: PathAnnotation, points: PointModel[], bounds: Rect, textElement: TextElement | DiagramHtmlElement, canRefresh?: number): void;
    /** @private */
    getConnectorPoints(type: Segments, points?: PointModel[], layoutOrientation?: LayoutOrientation): PointModel[];
    /** @private */
    private clipDecorator;
    /** @private */
    clipDecorators(connector: Connector, pts: PointModel[]): PointModel[];
    /** @private */
    updateSegmentElement(connector: Connector, points: PointModel[], element: PathElement): PathElement;
    /** @private */
    getSegmentElement(connector: Connector, segmentElement: PathElement): PathElement;
    /** @private */
    getDecoratorElement(offsetPoint: PointModel, adjacentPoint: PointModel, decorator: DecoratorModel, isSource: Boolean, getDescription?: Function): PathElement;
    private bridgePath;
    /** @private */
    updateDecoratorElement(element: DiagramElement, pt: PointModel, adjacentPoint: PointModel, decorator: DecoratorModel): void;
    /** @private */
    getSegmentPath(connector: Connector, points: PointModel[]): string;
    /** @private */
    updateShapeElement(connector: Connector): void;
    /** @private */
    updateShapePosition(connector: Connector, element: DiagramElement): void;
    /** @hidden */
    scale(sw: number, sh: number, width: number, height: number, refObject?: DiagramElement): PointModel;
}
