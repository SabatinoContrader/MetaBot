import { Node } from '../objects/node';
import { Connector } from '../objects/connector';
import { DataManager } from '@syncfusion/ej2-data';
import { randomId, getFunction } from '../utility/base-util';
/**
 * data source defines the basic unit of diagram
 */
var DataBinding = /** @class */ (function () {
    /**
     * Constructor for the data binding module.
     * @private
     */
    function DataBinding() {
        /**   @private  */
        this.dataTable = {};
        //constructs the data binding module
    }
    /**
     * To destroy the data binding module
     * @return {void}
     * @private
     */
    DataBinding.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    DataBinding.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DataBinding';
    };
    /**
     * Initialize nodes and connectors when we have a data as JSON
     * @param data
     * @param diagram
     * @private
     */
    DataBinding.prototype.initData = function (data, diagram) {
        var dataSource;
        var dataProp = 'data';
        var jsonProp = 'json';
        var dataManager = data.dataManager || {};
        dataSource = data.data || dataManager[dataProp] || dataManager[jsonProp] ||
            (dataManager.dataSource ? dataManager.dataSource.json : undefined);
        if (dataSource && dataSource.length) {
            this.applyDataSource(data, dataSource, diagram);
        }
    };
    /**
     * Initialize nodes and connector when we have a data as remote url
     * @param data
     * @param diagram
     * @private
     */
    DataBinding.prototype.initSource = function (data, diagram) {
        var _this = this;
        var dataSource = data;
        var result;
        var mapper = data;
        if (dataSource.dataManager instanceof DataManager) {
            var query = mapper.dataManager.defaultQuery;
            data.dataManager.executeQuery(query).then(function (e) {
                var prop = 'result';
                result = e[prop];
                if (!diagram.isDestroyed) {
                    _this.applyDataSource(data, result, diagram);
                    diagram.refreshDiagram();
                    diagram.trigger('dataLoaded', { diagram: diagram });
                }
            });
        }
    };
    DataBinding.prototype.applyDataSource = function (mapper, data, diagram) {
        this.dataTable = {};
        var obj;
        var firstNode;
        var rootNodes = [];
        var firstLevel = [];
        var item;
        var nextLevel;
        if (data !== undefined) {
            for (var r = 0; r < data.length; r++) {
                obj = data[r];
                if (obj[mapper.parentId] === undefined || obj[mapper.parentId] === null ||
                    typeof obj[mapper.parentId] !== 'object') {
                    if (rootNodes[obj[mapper.parentId]] !== undefined) {
                        rootNodes[obj[mapper.parentId]].items.push(obj);
                    }
                    else {
                        rootNodes[obj[mapper.parentId]] = { items: [obj] };
                    }
                }
                else {
                    rootNodes = this.updateMultipleRootNodes(obj, rootNodes, mapper, data);
                }
                if (mapper.root === obj[mapper.id]) {
                    firstNode = { items: [obj] };
                }
            }
            if (firstNode) {
                firstLevel.push(firstNode);
            }
            else {
                for (var _i = 0, _a = Object.keys(rootNodes); _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (!n || n === 'undefined' || n === '\'\'' || n === 'null') {
                        firstLevel.push(rootNodes[n]);
                    }
                }
            }
            for (var i = 0; i < firstLevel.length; i++) {
                for (var j = 0; j < firstLevel[i].items.length; j++) {
                    item = firstLevel[i].items[j];
                    var node = this.applyNodeTemplate(mapper, item, diagram);
                    diagram.nodes.push(node);
                    this.dataTable[item[mapper.id]] = node;
                    nextLevel = rootNodes[node.data[mapper.id]];
                    if (nextLevel !== undefined) {
                        this.renderChildNodes(mapper, nextLevel, node.id, rootNodes, diagram);
                    }
                }
            }
        }
        this.dataTable = null;
    };
    /**
     * updateMultipleRootNodes method is used  to update the multiple Root Nodes
     * @param object
     * @param rootnodes
     * @param mapper
     * @param data
     */
    DataBinding.prototype.updateMultipleRootNodes = function (obj, rootNodes, mapper, data) {
        var parents = obj[mapper.parentId];
        var parent;
        for (var i = 0; i < parents.length; i++) {
            parent = parents[i];
            if (rootNodes[parent]) {
                rootNodes[parent].items.push(obj);
            }
            else {
                rootNodes[parent] = { items: [obj] };
            }
        }
        return rootNodes;
    };
    /**
     * Get the node values
     * @param mapper
     * @param item
     * @param diagram
     */
    DataBinding.prototype.applyNodeTemplate = function (mapper, item, diagram) {
        var root = item;
        var id = randomId();
        var nodeModel = { id: id, data: item };
        var doBinding = getFunction(mapper.doBinding);
        if (doBinding) {
            doBinding(nodeModel, item, diagram);
        }
        var obj = new Node(diagram, 'nodes', nodeModel, true);
        if (!this.collectionContains(obj, diagram, mapper.id, mapper.parentId)) {
            return obj;
        }
        else {
            return this.dataTable[item[mapper.id]];
        }
    };
    DataBinding.prototype.renderChildNodes = function (mapper, parent, value, rtNodes, diagram) {
        var child;
        var nextLevel;
        var node;
        for (var j = 0; j < parent.items.length; j++) {
            child = parent.items[j];
            node = this.applyNodeTemplate(mapper, child, diagram);
            var canBreak = false;
            if (!this.collectionContains(node, diagram, mapper.id, mapper.parentId)) {
                this.dataTable[child[mapper.id]] = node;
                diagram.nodes.push(node);
            }
            else {
                canBreak = true;
            }
            if (!this.containsConnector(diagram, value, node.id)) {
                diagram.connectors.push(this.applyConnectorTemplate(value, node.id, diagram));
            }
            if (!canBreak) {
                nextLevel = rtNodes[node.data[mapper.id]];
                if (nextLevel !== undefined) {
                    this.renderChildNodes(mapper, nextLevel, node.id, rtNodes, diagram);
                }
            }
        }
    };
    DataBinding.prototype.containsConnector = function (diagram, sourceNode, targetNode) {
        if (sourceNode !== '' && targetNode !== '') {
            for (var i = 0; i < diagram.connectors.length; i++) {
                var connector = diagram.connectors[i];
                if (connector !== undefined && (connector.sourceID === sourceNode && connector.targetID === targetNode)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     *  collectionContains method is used to  check wthear the node is already present in collection or not
     * @param node
     * @param diagram
     * @param id
     * @param parentId
     */
    DataBinding.prototype.collectionContains = function (node, diagram, id, parentId) {
        var obj = this.dataTable[node.data[id]];
        if (obj !== undefined && obj.data[id] === node.data[id] && obj.data[parentId] === node.data[parentId]) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Get the Connector values
     * @param sourceNode
     * @param targetNode
     * @param diagram
     */
    DataBinding.prototype.applyConnectorTemplate = function (sNode, tNode, diagram) {
        var connModel = {
            id: randomId(), sourceID: sNode, targetID: tNode
        };
        var obj = new Connector(diagram, 'connectors', connModel, true);
        return obj;
    };
    return DataBinding;
}());
export { DataBinding };
