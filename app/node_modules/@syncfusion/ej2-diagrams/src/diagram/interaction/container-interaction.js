import { Node } from '../objects/node';
import { Selector } from './selector';
import { Size } from '../primitives/size';
import { cloneObject } from './../utility/base-util';
import { getObjectType } from './../utility/diagram-util';
import { RowDefinition, ColumnDefinition } from '../core/containers/grid';
import { Rect } from '../primitives/rect';
import { getAdornerLayerSvg } from '../utility/dom-util';
import { DiagramElement } from '../core/elements/diagram-element';
import { NodeConstraints } from '../enum/enum';
/**
 * Interaction for Container
 */
//#region canvas Container interaction
/** @private */
export function updateCanvasBounds(diagram, obj, position, isBoundsUpdate) {
    var container;
    if (checkParentAsContainer(diagram, obj, true)) {
        container = diagram.nameTable[obj.parentId];
        var wrapper = container.wrapper;
        if (container && container.container.type === 'Canvas') {
            if ((isBoundsUpdate || (wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&
                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y)))) {
                if (wrapper.actualSize.width < wrapper.outerBounds.width &&
                    (!(wrapper.bounds.x > wrapper.outerBounds.x))) {
                    if (container.rowIndex !== undefined) {
                        var parent_1 = diagram.nameTable[container.parentId];
                        if (parent_1.columns.length - 1 === container.columnIndex) {
                            var x = wrapper.bounds.x;
                            var y = wrapper.bounds.y;
                            (wrapper).maxWidth = wrapper.outerBounds.width;
                            parent_1.wrapper.updateColumnWidth(container.columnIndex, wrapper.outerBounds.width);
                            diagram.drag(parent_1, x - wrapper.bounds.x, y - wrapper.bounds.y);
                            diagram.updateDiagramObject(parent_1);
                        }
                    }
                    else {
                        diagram.scale(container, (1 + ((wrapper.outerBounds.width - wrapper.actualSize.width) / wrapper.actualSize.width)), 1, ((wrapper.outerBounds.x < wrapper.bounds.x) ? { x: 1, y: 0.5 } : { x: 0, y: 0.5 }));
                    }
                }
                if (wrapper.actualSize.height < wrapper.outerBounds.height &&
                    (!(wrapper.bounds.y > wrapper.outerBounds.y))) {
                    if (container.rowIndex !== undefined) {
                        var contai = diagram.nameTable[container.parentId];
                        var x = wrapper.bounds.x;
                        var y = wrapper.bounds.y;
                        (wrapper).maxHeight = wrapper.outerBounds.height;
                        contai.wrapper.updateRowHeight(container.rowIndex, wrapper.outerBounds.height);
                        diagram.drag(contai, x - wrapper.bounds.x, y - wrapper.bounds.y);
                    }
                    else {
                        diagram.scale(container, 1, (1 + ((wrapper.outerBounds.height - wrapper.actualSize.height) / wrapper.actualSize.height)), ((wrapper.outerBounds.y < wrapper.bounds.y) ? { x: 0.5, y: 1 } : { x: 0.5, y: 0 }));
                    }
                }
            }
            else if (container.container.type === 'Canvas') {
                var undoObj = cloneObject(obj);
                diagram.clearSelection();
                diagram.deleteChild(obj);
                obj.parentId = '';
                var entry = {
                    type: 'ChildCollectionChanged', category: 'Internal',
                    undoObject: undoObj, redoObject: cloneObject(obj)
                };
                diagram.addHistoryEntry(entry);
            }
            diagram.select([obj]);
        }
    }
}
/** @private */
export function findBounds(obj, columnIndex, isHeader) {
    var rect = new Rect();
    var rows = (obj.shape.type === 'SwimLane') ?
        obj.wrapper.children[0].rows : obj.wrapper.rows;
    for (var i = ((isHeader) ? 1 : 0); i < rows.length; i++) {
        rect.uniteRect(rows[i].cells[columnIndex].bounds);
    }
    return rect;
}
/** @private */
export function createHelper(diagram, obj) {
    var newObj;
    var cloneObject = {};
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var prop = _a[_i];
        cloneObject[prop] = obj[prop];
    }
    if (getObjectType(obj) === Node) {
        newObj = new Node(diagram, 'nodes', cloneObject, true);
        newObj.id = obj.id;
        diagram.initObject(newObj);
    }
    diagram.updateDiagramObject(newObj);
    return newObj;
}
/** @private */
export function renderContainerHelper(diagram, obj) {
    var object;
    var nodes;
    if (diagram.selectedObject.helperObject) {
        nodes = diagram.selectedObject.helperObject;
    }
    else {
        if (obj instanceof Selector && obj.nodes.length + obj.connectors.length === 1) {
            object = (obj.nodes.length > 0) ? obj.nodes[0] : obj.connectors[0];
        }
        else {
            object = obj;
        }
        diagram.selectedObject.actualObject = object;
        var container = diagram.selectedItems.wrapper.children[0];
        if (checkParentAsContainer(diagram, object)) {
            var node = {
                id: 'helper',
                rotateAngle: container.rotateAngle,
                offsetX: container.offsetX, offsetY: container.offsetY,
                minWidth: container.minWidth, minHeight: container.minHeight,
                maxWidth: container.maxWidth, maxHeight: container.maxHeight,
                width: container.actualSize.width,
                height: container.actualSize.height,
                style: { strokeDashArray: '2 2', fill: 'transparent', strokeColor: 'red' }
            };
            nodes = createHelper(diagram, node);
            diagram.selectedObject.helperObject = nodes;
        }
    }
    return nodes;
}
/** @private */
export function checkParentAsContainer(diagram, obj, isChild) {
    var parentNode = (isChild) ? diagram.nameTable[obj.parentId] :
        (diagram.nameTable[obj.parentId] || obj);
    if (parentNode && parentNode.container) {
        return true;
    }
    return false;
}
/** @private */
export function checkChildNodeInContainer(diagram, obj) {
    var parentNode = diagram.nameTable[obj.parentId];
    if (parentNode.container.type === 'Canvas') {
        obj.margin.left = (obj.offsetX - parentNode.wrapper.bounds.x - (obj.width / 2));
        obj.margin.top = (obj.offsetY - parentNode.wrapper.bounds.y - (obj.height / 2));
    }
    diagram.nodePropertyChange(obj, {}, {
        width: obj.width, height: obj.height,
        offsetX: obj.offsetX, offsetY: obj.offsetY,
        margin: {
            left: obj.margin.left,
            right: obj.margin.right, top: obj.margin.top,
            bottom: obj.margin.bottom
        }, rotateAngle: obj.rotateAngle
    });
    parentNode.wrapper.measure(new Size());
    parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
}
/**
 * @private
 */
export function addChildToContainer(diagram, parent, node) {
    if (!diagram.currentSymbol) {
        var child = (diagram.nodes.indexOf(node) !== -1) ? node.id : node;
        if (parent.container.type === 'Canvas') {
            var left = (node.wrapper.offsetX - node.wrapper.actualSize.width / 2) -
                (parent.wrapper.offsetX - parent.wrapper.actualSize.width / 2);
            var top_1 = (node.wrapper.offsetY - node.wrapper.actualSize.height / 2) -
                (parent.wrapper.offsetY - parent.wrapper.actualSize.height / 2);
            node.margin.left = left;
            node.margin.top = top_1;
        }
        var container = diagram.nameTable[parent.id];
        if (!container.children) {
            container.children = [];
        }
        if (container.children.indexOf(node.id) === -1) {
            if (node.parentId !== '') {
                diagram.deleteChild(node);
            }
            var undoObj = cloneObject(node);
            diagram.addChild(container, child);
            var entry = {
                type: 'ChildCollectionChanged', category: 'Internal',
                undoObject: undoObj, redoObject: cloneObject(node)
            };
            diagram.addHistoryEntry(entry);
            diagram.updateDiagramObject(container);
        }
    }
}
//#endregion
//# reginon stack panel interaction
/** @private */
export function renderStackHighlighter(element, isVertical, position, diagram, isUml) {
    var adornerSvg = getAdornerLayerSvg(diagram.element.id);
    diagram.diagramRenderer.renderStackHighlighter(element, adornerSvg, diagram.scroller.transform, isVertical, position, isUml);
}
/** @private */
export function moveChildInStack(sourceNode, target, diagram, action) {
    var obj = sourceNode;
    var parent = diagram.nameTable[obj.parentId];
    var sourceParent = diagram.nameTable[obj.parentId];
    if (target && sourceParent && sourceParent.container && sourceParent.container.type === 'Stack' &&
        target.container && target.container.type === 'Stack' && (sourceParent.id !== target.parentId)) {
        var value = sourceParent.wrapper.children.indexOf(obj.wrapper);
        if (value > -1) {
            diagram.nameTable[obj.id].parentId = target.id;
            sourceParent.wrapper.children.splice(value, 1);
        }
    }
    if (target && target.parentId && obj.parentId && action === 'Drag') {
        var targetIndex = parent.wrapper.children.indexOf(target.wrapper);
        var sourceIndex = parent.wrapper.children.indexOf(obj.wrapper);
        var undoElement = {
            targetIndex: targetIndex, target: target,
            sourceIndex: sourceIndex, source: sourceNode
        };
        parent.wrapper.children.splice(sourceIndex, 1);
        parent.wrapper.children.splice(targetIndex, 0, obj.wrapper);
        var redoElement = {
            targetIndex: sourceIndex, target: target,
            sourceIndex: targetIndex, source: sourceNode
        };
        var entry = {
            type: 'StackChildPositionChanged', redoObject: redoElement,
            undoObject: undoElement, category: 'Internal'
        };
        diagram.commandHandler.addHistoryEntry(entry);
    }
}
//#end region
//# region Swimlane rendering
/** @private */
export function initSwimLane(grid, diagram, node) {
    var row = [];
    var columns = [];
    var orientation = node.shape.orientation === 'Horizontal' ? true : false;
    if (node.shape.header) {
        createRow(row, node.shape.header.height);
    }
    initGridRow(row, orientation, node);
    initGridColumns(columns, orientation, node);
    grid.setDefinitions(row, columns);
    var index = 0;
    if (node.shape.header) {
        headerDefine(grid, diagram, node);
        index++;
    }
    if (node.shape.phases.length > 0) {
        phaseDefine(grid, diagram, node, index, orientation);
        index++;
    }
    if (node.shape.lanes.length > 0) {
        for (var k = 0; k < node.shape.lanes.length; k++) {
            laneCollection(grid, diagram, node, index, k, orientation);
            index++;
        }
    }
}
/** @private */
export function addObjectToGrid(diagram, grid, parent, object, isHeader) {
    var node = new Node(parent, 'nodes', object);
    node.parentId = grid.id;
    if (isHeader) {
        node.isHeader = true;
    }
    diagram.initObject(node);
    if (node.wrapper.children.length > 0) {
        for (var i = 0; i < node.wrapper.children.length; i++) {
            var child = node.wrapper.children[i];
            if (child instanceof DiagramElement) {
                child.isCalculateDesiredSize = false;
            }
        }
    }
    return node.wrapper;
}
// /** @private */
// export function addGridObject(
//     diagram: Diagram, grid: Grid, object: NodeModel, isHeader?: boolean, rowValue?: number, colValue?: number,
//     nodeObj?: NodeModel, orientation?: boolean, lanesNo?: number): void {
//     let node: Node = new Node(object, 'nodes', { container: { type: 'Canvas', orientation: 'Horziontal' } });
//     diagram.initObject(node as IElement);
//     node.parentId = grid.id;
//     if (isHeader) {
//         (node as Node).isHeader = true;
//     }
//     diagram.nodes.push(node);
//     let canvas: Container = node.wrapper;
//     node.rowIndex = rowValue; node.columnIndex = colValue;
//     canvas.children = [];
//     if (nodeObj) {
//         if (lanesNo !== undefined) {
//             orientation ? canvas.verticalAlignment = 'Stretch' : canvas.horizontalAlignment = 'Stretch';
//             canvas.relativeMode = 'Object';
//             if (orientation) {
//                 nodeObj.width = (object.shape as SwimLaneModel).lanes[lanesNo].header.width;
//             } else {
//                 nodeObj.height = (object.shape as SwimLaneModel).lanes[lanesNo].header.width;
//             }
//         }
//         let node: Node = new Node(object, 'nodes', nodeObj);
//         node.parentId = grid.id;
//         node.rowIndex = rowValue; node.columnIndex = colValue;
//         if (isHeader) {
//             (node as Node).isHeader = true;
//         }
//         diagram.initObject(node);
//         if (lanesNo === undefined) {
//             if (isHeader) {
//                 node.wrapper.horizontalAlignment = 'Stretch';
//             } else {
//                 orientation ? node.wrapper.horizontalAlignment = 'Stretch' : node.wrapper.verticalAlignment = 'Stretch';
//             }
//             canvas.horizontalAlignment = node.wrapper.horizontalAlignment;
//             canvas.verticalAlignment = node.wrapper.verticalAlignment;
//             canvas.relativeMode = node.wrapper.relativeMode = 'Object';
//         } else {
//             orientation ? node.wrapper.verticalAlignment = 'Stretch' : node.wrapper.horizontalAlignment = 'Stretch';
//             node.wrapper.relativeMode = 'Object';
//         }
//         if (node.wrapper.children.length > 0) {
//             for (let i: number = 0; i < node.wrapper.children.length; i++) {
//                 let child: DiagramElement = node.wrapper.children[i];
//                 if (child instanceof DiagramElement) {
//                     child.isCalculateDesiredSize = false;
//                 }
//             }
//         }
//         canvas.children.push(node.wrapper);
//     }
//     grid.addObject(canvas, rowValue, colValue, 1, (isHeader) ? grid.columnDefinitions().length : 1);
// }
/** @private */
export function headerDefine(grid, diagram, object) {
    var node = {
        annotations: [{ content: object.shape.header.content.content }],
        style: object.shape.header.style,
        rowIndex: 0, columnIndex: 0,
        container: { type: 'Canvas', orientation: 'Horizontal' }
    };
    var wrapper = addObjectToGrid(diagram, grid, object, node, true);
    grid.addObject(wrapper, 0, 0, 1, grid.columnDefinitions().length);
}
/** @private */
export function phaseDefine(grid, diagram, object, indexValue, orientation) {
    var rowValue = 0;
    var colValue = 0;
    for (var k = 0; k < object.shape.phases.length; k++) {
        if (orientation) {
            colValue = k;
            rowValue = indexValue;
        }
        else {
            rowValue = object.shape.header ? k + 1 : k;
        }
        var phaseObject = {
            annotations: [{
                    content: object.shape.phases[k].header.content.content,
                    rotateAngle: orientation ? 0 : 270
                }],
            style: object.shape.phases[k].style,
            rowIndex: rowValue, columnIndex: colValue,
            container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
        };
        var wrapper = addObjectToGrid(diagram, grid, object, phaseObject);
        grid.addObject(wrapper, rowValue, colValue);
    }
}
/** @private */
export function laneCollection(grid, diagram, object, indexValue, laneIndex, orientation) {
    var value = object.shape.phases.length || 1;
    var colValue = 0;
    var rowValue = orientation ? indexValue : 1;
    var phaseCount = object.shape.phases.length > 0 ? 1 : 0;
    for (var l = 0; l < value; l++) {
        colValue = orientation ? l : laneIndex + phaseCount;
        var canvas = {
            id: object.shape.lanes[laneIndex].id + l,
            rowIndex: rowValue, columnIndex: colValue,
            style: object.shape.lanes[laneIndex].style,
            constraints: NodeConstraints.Default | NodeConstraints.AllowDrop,
            container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
        };
        var parentWrapper = addObjectToGrid(diagram, grid, object, canvas);
        parentWrapper.children[0].isCalculateDesiredSize = false;
        if (l === 0) {
            var laneNode = void 0;
            laneNode = {
                id: object.shape.lanes[laneIndex].id + '_header',
                style: object.shape.lanes[laneIndex].header.style,
                annotations: [{
                        content: object.shape.lanes[laneIndex].header.content.content,
                        rotateAngle: orientation ? 270 : 0
                    }],
                rowIndex: rowValue, columnIndex: colValue,
                container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
            };
            (orientation) ? laneNode.width = object.shape.lanes[laneIndex].header.width :
                laneNode.height = object.shape.lanes[laneIndex].header.width;
            var childWrapper = addObjectToGrid(diagram, grid, object, laneNode);
            parentWrapper.children.push(childWrapper);
        }
        grid.addObject(parentWrapper, rowValue, colValue);
        if (!orientation) {
            rowValue++;
        }
        colValue = orientation ? l : laneIndex + 1;
    }
}
// /** @private */
// export function laneDefine(
//     grid: Grid, diagram: Diagram, object: NodeModel, indexValue: number, laneIndex: number, orientation: boolean): void {
//     let value: number = orientation ? grid.columnDefinitions().length : (object.shape as SwimLaneModel).phases.length || 1;
//     let colValue: number = 0;
//     let rowValue: number = 0;
//     let phaseLength: number = (object.shape as SwimLaneModel).phases.length > 0 ? 1 : 0;
//     rowValue = orientation ? indexValue : 1;
//     for (let l: number = 0; l < value; l++) {
//         colValue = orientation ? l : laneIndex + phaseLength;
//         let node: NodeModel = {
//             style: (object.shape as SwimLaneModel).lanes[laneIndex].style, width: object.width, height: object.height
//         };
//         addGridObject(diagram, grid, object, false, orientation ? rowValue : rowValue, colValue);
//         if (l === 0) {
//             let laneNode: NodeModel;
//             laneNode = {
//                 id: (object.shape as SwimLaneModel).lanes[laneIndex].id,
//                 style: (object.shape as SwimLaneModel).lanes[laneIndex].header.style,
//                 annotations: [{
//                     content: (object.shape as SwimLaneModel).lanes[laneIndex].header.content.content,
//                     rotateAngle: orientation ? 270 : 0
//                 }],
//                 container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
//             };
//             addGridObject(diagram, grid, object, false, rowValue, orientation ? 0 : colValue, laneNode, orientation, laneIndex);
//         }
//         if (!orientation) {
//             rowValue++;
//         }
//         colValue = orientation ? l : laneIndex + 1;
//     }
// }
/** @private */
export function createRow(row, height) {
    var rows = new RowDefinition();
    rows.height = height;
    row.push(rows);
}
/** @private */
export function createColumn(width) {
    var cols = new ColumnDefinition();
    cols.width = width;
    return cols;
}
/** @private */
export function initGridRow(row, orientation, object) {
    var totalHeight = 0;
    var height;
    if (row.length > 0) {
        for (var i = 0; i < row.length; i++) {
            totalHeight += row[i].height;
        }
    }
    if (orientation) {
        if (object.shape.phases.length > 0) {
            totalHeight += object.shape.phases[0].height;
            createRow(row, object.shape.phases[0].height);
        }
        if (object.shape.lanes.length > 0) {
            for (var i = 0; i < object.shape.lanes.length; i++) {
                height = object.shape.lanes[i].height;
                totalHeight += height;
                if (i === object.shape.lanes.length - 1 && totalHeight < object.height) {
                    height += object.height - totalHeight;
                }
                createRow(row, height);
            }
        }
    }
    else {
        if (object.shape.phases.length > 0) {
            for (var i = 0; i < object.shape.phases.length; i++) {
                height = object.shape.phases[i].offset;
                totalHeight += height;
                if (i === object.shape.phases.length - 1 && totalHeight < object.height) {
                    height += object.height - totalHeight;
                }
                createRow(row, height);
            }
        }
        else {
            createRow(row, object.height);
        }
    }
}
/** @private */
export function initGridColumns(columns, orientation, object) {
    var totalWidth = 0;
    if (object.shape.phases.length > 0 && object.shape.orientation === 'Horizontal') {
        for (var j = 0; j < object.shape.phases.length; j++) {
            totalWidth += object.shape.phases[j].offset;
            var cols = createColumn(object.shape.phases[j].offset);
            if (j === object.shape.phases.length - 1 && totalWidth < object.width) {
                cols.width += object.width - totalWidth;
            }
            columns.push(cols);
        }
    }
    else if (!orientation) {
        var value = object.shape.phases.length > 0 ? object.shape.lanes.length
            + 1 : object.shape.lanes.length;
        for (var j = 0; j < value; j++) {
            if (j === 0 && object.shape.phases.length > 0) {
                totalWidth += object.shape.phases[0].height;
                var cols = createColumn(object.shape.phases[0].height);
                columns.push(cols);
            }
            else {
                totalWidth += object.shape.lanes[0].height;
                var cols = createColumn(object.shape.lanes[0].height);
                if (j === object.shape.lanes.length && totalWidth < object.width) {
                    cols.width += object.width - totalWidth;
                }
                columns.push(cols);
            }
        }
    }
    else {
        var cols = createColumn(object.width);
        columns.push(cols);
    }
}
//#end region
